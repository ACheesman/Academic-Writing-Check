#!/usr/bin/env perl
#
# Author : Devdatta Akhawe  http://www.cs.berkeley.edu/~devdatta 
#
#
# Finds passive, duplicate and weasel words being used
# Original Idea and list of words by Matthew Might
# http://matt.might.net/articles/shell-scripts-for-passive-voice-weasel-words-duplicates/

use strict ;
use warnings;
use Getopt::Long;

my %options=( 
  'passive' => 1,
  'dups'=> 1,
  'weasel'=> 1,
  'abbr'=> 1,
  'strunk'=> 0,
  'footnote'=>1,
  'number'=>1,
  'url' => 1
  );
GetOptions( \%options, 'passive!','dups!','weasel!','abbr!','strunk!','footnote!','number!','url!');
# Color codes are at http://www.cyberciti.biz/faq/bash-shell-change-the-color-of-my-shell-prompt-under-linux-or-unix/
#TODO : Add support for colors on command line
my ($passive_color,$dup_color,$weasel_color,$strunk_color,$def_color) = (
"\e[1;31m",
"\e[1;33m",
"\e[1;32m",
"\e[1;35m",
"\e[0m",
);

my $filename="";

if($#ARGV==0 and -d $ARGV[0]){
  my $dirname=shift @ARGV;
  $dirname =~ s/\/$//;
  @ARGV=(<$dirname/*.tex>);
  push @ARGV,(<$dirname/*bbl>); 
}

my $str='';
#use stdin if no file available
@ARGV=("/dev/stdin") unless @ARGV;

while(($filename=shift @ARGV)){
    open FILE,$filename or die "Error opening $filename";
    {
      local $/;
      $str=<FILE>;
    }
    close(FILE);
    my $count=0;
    $count += fixURL() if $options{'url'};
    unless($filename =~ m/bbl$/){
    #spaces since \b on both sides had too many false positives like -,:
    $count += ($str =~ s/(\s\d{4,}\b)/\x{EFFF}$dup_color$1$def_color\x{EFFF}/go) if $options{'number'};
    $count += fixFootnote() if $options{'footnote'};
    $count += fixPassive() if $options{'passive'};
    $count += fixDups() if $options{'dups'};
    $count += fixWeasel() if $options{'weasel'};
    $count += fixStrunk() if $options{'strunk'};
    $count += fixAbbr() if $options{'abbr'};
    }
    next unless $count;
    my $linenum=0;
    $filename =~ m/([^\/]*)$/;
    $filename = $1;
    my $extra="";
    foreach my $line (split("\n",$str)){
      $linenum++;
      next unless $line =~ m/\x{EFFF}/;
      $line =~ s/\x{EFFF}//g;
      # we can't do this while setting str since that messes up line numbers
      # I am pretty sure this is ok since the % would prevent match across lines
      next if $line =~ m/^\s*%/;
      print "$filename:$linenum: $line\n";      
      $extra =1 ;
    }
    # some spacing from the new file
    print "\n" if @ARGV and $extra;
    
}

sub fixPassive{
  my @irregulars=(
"awoken",
"been","born","beat",
"become","begun","bent",
"beset","bet","bid",
"bidden","bound","bitten",
"bled","blown","broken",
"bred","brought","broadcast",
"built","burnt","burst",
"bought","cast","caught",
"chosen","clung","come",
"cost","crept","cut",
"dealt","dug","dived",
"done","drawn","dreamt",
"driven","drunk","eaten","fallen",
"fed","felt","fought","found",
"fit","fled","flung","flown",
"forbidden","forgotten",
"foregone","forgiven",
"forsaken","frozen",
"gotten","given","gone",
"ground","grown","hung",
"heard","hidden","hit",
"held","hurt","kept","knelt",
"knit","known","laid","led",
"leapt","learnt","left",
"lent","let","lain","lighted",
"lost","made","meant","met",
"misspelt","mistaken","mown",
"overcome","overdone","overtaken",
"overthrown","paid","pled","proven",
"put","quit","read","rid","ridden",
"rung","risen","run","sawn","said",
"seen","sought","sold","sent",
"set","sewn","shaken","shaven",
"shorn","shed","shone","shod",
"shot","shown","shrunk","shut",
"sung","sunk","sat","slept",
"slain","slid","slung","slit",
"smitten","sown","spoken","sped",
"spent","spilt","spun","spit",
"split","spread","sprung","stood",
"stolen","stuck","stung","stunk",
"stridden","struck","strung",
"striven","sworn","swept",
"swollen","swum","swung","taken",
"taught","torn","told","thought",
"thrived","thrown","thrust",
"trodden","understood","upheld",
"upset","woken","worn","woven",
"wed","wept","wound","won",
"withheld","withstood","wrung",
"written");
  my $regex = '\b(am|are|were|being|is|been|was|be)\b(\s+)(\w+ed|('.join('|',@irregulars).'))\b';
  return $str =~ s/$regex/\x{EFFF}$passive_color$1$def_color$2$passive_color$3$def_color\x{EFFF}/goi;
}

sub fixWeasel{
 #TODO add better support for wordfile
 my $regex ='\b(many|various|very|fairly|several|extremely|exceedingly|quite|remarkably|few|surprisingly|mostly|largely|huge|tiny|((are|is) a number)|excellent|interestingly|significantly|substantially|clearly|vast|relatively|completely)\b';
 return $str =~ s/$regex/\x{EFFF}$weasel_color$1$def_color\x{EFFF}/goi;
}

sub fixDups{
return $str =~ s/\b(\w+)(\s+)(\1)\b/\x{EFFF}$dup_color$1$def_color$2$dup_color$3$def_color\x{EFFF}/iog;
}

sub fixAbbr{
  return $str =~ s/\b(et\.\s+al\.|et\.\s+al|i\.e)\b/\x{EFFF}$dup_color$1$def_color\x{EFFF}/iog;
}

sub fixStrunk{
  my $count=0;
  $count += fixStrunkRule2();
  return $count;
}

sub fixFootnote{
  return $str =~ s/(\\footnote)(\{(?:(?>[^{}]+)|(?2))+\})([.,:=;-])/\x{EFFF}$dup_color$1$def_color\x{EFFF}$2\x{EFFF}$dup_color$3$def_color\x{EFFF}/og;
}

sub fixStrunkRule2{
  #broken broken broken
  my $word = qr/[a-z]{2,}/;
  my $words = qr/$word(?:\s+$word)*/;
  return $str =~ s/(,\s*$words\s*)(?=\s+and\s*$words)/\x{EFFF}$strunk_color$1$def_color\x{EFFF}/goi;
}


sub fixURL{
  #http://daringfireball.net/2010/07/improved_regex_for_matching_urls
  my $regex=qr{
  \b
  (                       # Capture 1: entire matched URL
    (?:
      (ht|f)tps?:\/\/               # http or https protocol
      |                       #   or
      www\d{0,3}[.]           # "www.", "www1.", "www2." … "www999."
      |                           #   or
      [a-z0-9.\-]+[.][a-z]{2,4}\/  # looks like domain name followed by a slash
    )
    (?:                       # One or more:
      [^\s()<>]+                  # Run of non-space, non-()<>
      |                           #   or
      \(([^\s()<>]+|(\([^\s()<>]+\)))*\)  # balanced parens, up to 2 levels
    )+
    (?:                       # End with:
      \(([^\s()<>]+|(\([^\s()<>]+\)))*\)  # balanced parens, up to 2 levels
      |                               #   or
      [^\s`!()\[\]{};:'".,<>?«»“”‘’]        # not a space or one of these punct chars
    )
  )}x;
  $str =~ s/(\\url\{[^}]*\})|($regex)/$1 || "\x{EFFF}$dup_color$2$def_color\x{EFFF}"/eog;
}