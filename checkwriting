#!/usr/bin/env perl
#
# Author : Devdatta Akhawe  http://www.cs.berkeley.edu/~devdatta 
#

# Original Idea and list of words by Matthew Might
# http://matt.might.net/articles/shell-scripts-for-passive-voice-weasel-words-duplicates/

use strict ;
use warnings;
use Getopt::Long;

my %options=( 
  'passive' => 1,
  'dups'=> 1,
  'weasel'=> 1,
  'abbr'=> 1,
  'typography'=>1,
  'invert'=>0
  );
GetOptions( \%options, 'passive!','dups!','weasel!','abbr!','typography!','invert');
# Color codes are at http://www.cyberciti.biz/faq/bash-shell-change-the-color-of-my-shell-prompt-under-linux-or-unix/
#TODO : Add support for colors on command line
if($options{'invert'}){
  $options{$_}= (($options{$_}+1)%2) foreach (keys %options);
}

my ($passive_color,$typography_color,$weasel_color,$dup_color,$abbr_color,$def_color) = (
"\e[1;31m",
"\e[1;33m",
"\e[1;32m",
"\e[1;35m",
"\e[1;34m",
"\e[0m",
);

my $filename="";
my @files=@ARGV;
if($#files==0 and -d $files[0]){
  my $dirname=shift @files;
  $dirname =~ s/\/$//;
  @files= glob("$dirname/*tex $dirname/*bbl");
}

my $str='';
#use stdin if no file available
@files=("/dev/stdin") unless @files;

while(($filename=shift @files)){
    {
    open my $fh,'<',$filename or die "Error opening $filename";
    local $/;
    $str=<$fh>;
    close($fh);
    }
    
    my $count=0;
    if($filename =~ m/bbl$/){
      #for bbl files only look for URL errors
      $count += fixURL() if $options{'typography'};
    }else{
    #spaces since \b on both sides had too many false positives like -,:
    $count += fixTypography() if $options{'typography'};
    $count += fixPassive() if $options{'passive'};
    $count += fixDups() if $options{'dups'};
    $count += fixWeasel() if $options{'weasel'};
#     $count += fixStrunk() if $options{'strunk'};
    $count += fixAbbr() if $options{'abbr'};
    }
    next unless $count;
    my $linenum=0;
    if($filename =~ m/([^\/]*)$/){
        $filename = $1 ;
    }
    my $extra="";
    while($str =~ m/(.+)/g){
      my $line=$1;
      $linenum++;
      next unless $line =~ m/\x{EFFF}/;
      $line =~ s/\x{EFFF}//g;
      # we can't do this while setting str since that messes up line numbers
      # I am pretty sure this is ok since the % would prevent match across lines
      next if $line =~ m/^\s*%/;
      print "$filename:$linenum: $line\n";      
      $extra =1 ;
    }
    # some spacing from the new file
    print "\n" if @files and $extra;
    
}

sub fixPassive{
  my @irregulars=(
"awoken",
"been","born","beat",
"become","begun","bent",
"beset","bet","bid",
"bidden","bound","bitten",
"bled","blown","broken",
"bred","brought","broadcast",
"built","burnt","burst",
"bought","cast","caught",
"chosen","clung","come",
"cost","crept","cut",
"dealt","dug","dived",
"done","drawn","dreamt",
"driven","drunk","eaten","fallen",
"fed","felt","fought","found",
"fit","fled","flung","flown",
"forbidden","forgotten",
"foregone","forgiven",
"forsaken","frozen",
"gotten","given","gone",
"ground","grown","hung",
"heard","hidden","hit",
"held","hurt","kept","knelt",
"knit","known","laid","led",
"leapt","learnt","left",
"lent","let","lain","lighted",
"lost","made","meant","met",
"misspelt","mistaken","mown",
"overcome","overdone","overtaken",
"overthrown","paid","pled","proven",
"put","quit","read","rid","ridden",
"rung","risen","run","sawn","said",
"seen","sought","sold","sent",
"set","sewn","shaken","shaven",
"shorn","shed","shone","shod",
"shot","shown","shrunk","shut",
"sung","sunk","sat","slept",
"slain","slid","slung","slit",
"smitten","sown","spoken","sped",
"spent","spilt","spun","spit",
"split","spread","sprung","stood",
"stolen","stuck","stung","stunk",
"stridden","struck","strung",
"striven","sworn","swept",
"swollen","swum","swung","taken",
"taught","torn","told","thought",
"thrived","thrown","thrust",
"trodden","understood","upheld",
"upset","woken","worn","woven",
"wed","wept","wound","won",
"withheld","withstood","wrung",
"written");
  my $regex = '\b(am|are|were|being|is|been|was|be)\b(\s+)(\w+ed|('.join('|',@irregulars).'))\b';
  return $str =~ s/$regex/\x{EFFF}$passive_color$1$def_color$2$passive_color$3$def_color\x{EFFF}/goi;
}

sub fixWeasel{
 #TODO add better support for wordfile
 my $regex ='\b(many|various|very|fairly|several|extremely|exceedingly|quite|remarkably|few|surprisingly|mostly|largely|huge|tiny|((are|is) a number)|excellent|interestingly|significantly|substantially|clearly|vast|relatively|completely)\b';
 return $str =~ s/$regex/\x{EFFF}$weasel_color$1$def_color\x{EFFF}/goi;
}

sub fixDups{
return $str =~ s/\b(\w+)(\s+)(\1)\b/\x{EFFF}$dup_color$1$def_color$2$dup_color$3$def_color\x{EFFF}/iog;
}

sub fixAbbr{
  my $c = ($str =~ s/\b((?:et\.\s+al\.|et\.\s+al|i\.e) )/\x{EFFF}$abbr_color$1$def_color\x{EFFF}/og);
  return $c;
}

sub fixStrunk{
  my $count=0;
  $count += fixStrunkRule2();
  return $count;
}

sub fixTypography{
  my $c= 0;
  #footnotes look better if started after punctuations
  $c +=  ($str =~ s/(\\footnote)(\{(?:(?>[^{}]+)|(?2))+\})([.,:=;-])/\x{EFFF}$typography_color$1$def_color\x{EFFF}$2\x{EFFF}$typography_color$3$def_color\x{EFFF}/og);
  #Latex assumes a '.' ends a sentence unless its after a uppercase letter
  #http://www.ece.ucdavis.edu/~jowens/commonerrors.html
  $c += ($str =~ s/\b((?:et\sal\.|e\.g\.|i\.e\.) )/\x{EFFF}$typography_color$1<slash escape the space>$def_color\x{EFFF}/og);
  $c += ($str =~ s/\b([A-Z]\.)/\x{EFFF}$typography_color$1<add a \\\@>$def_color\x{EFFF}/og);
  $c += ($str =~ s/(\s\d{4,}\b)/\x{EFFF}$typography_color$1$def_color\x{EFFF}/go) if $options{'number'};
  #URLs should be typeset with \url
  $c += fixURL();
  return $c;
}

sub fixStrunkRule2{
  #broken broken broken
  my $word = qr/[a-z]{2,}/;
  my $words = qr/$word(?:\s+$word)*/;
  return $str =~ s/(,\s*$words\s*)(?=\s+and\s*$words)/\x{EFFF}$dup_color$1$def_color\x{EFFF}/goi;
}


sub fixURL{
  #http://daringfireball.net/2010/07/improved_regex_for_matching_urls
  my $regex=qr{
  \b
  (                       # Capture 1: entire matched URL
    (?:
      (ht|f)tps?:\/\/               # http or https protocol
      |                       #   or
      www\d{0,3}[.]           # "www.", "www1.", "www2." … "www999."
      |                           #   or
      [a-z0-9.\-]+[.][a-z]{2,4}\/  # looks like domain name followed by a slash
    )
    (?:                       # One or more:
      [^\s()<>]+                  # Run of non-space, non-()<>
      |                           #   or
      \(([^\s()<>]+|(\([^\s()<>]+\)))*\)  # balanced parens, up to 2 levels
    )+
    (?:                       # End with:
      \(([^\s()<>]+|(\([^\s()<>]+\)))*\)  # balanced parens, up to 2 levels
      |                               #   or
      [^\s`!()\[\]{};:'".,<>?«»“”‘’]        # not a space or one of these punct chars
    )
  )}x;
  return $str =~ s/(\\url\{[^}]*\})|($regex)/$1 || "\x{EFFF}$typography_color$2$def_color\x{EFFF}"/eog;
}